"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useMounted = exports.useI18nLoaded = exports.useI18n = exports.I18NextReactProvider = void 0;
/**
 * yet another binding for i18next
 * it's so damn hard to get react-18next work in next
 *
 * - required
 */
const react_1 = require("react");
const I18NextReactContext = react_1.createContext(null);
const inServer = typeof window === 'undefined';
/**
 * A HOC to hold i18n instance InternalI18nState
 * @param {string|undefined} props.lang
 * @param {I18NFactory} props.factory see {@link I18NFactory}
 */
exports.I18NextReactProvider = (props) => {
    const mounted = useMounted();
    const [internal, setInternal] = react_1.useState(() => {
        const instance = props.factory(inServer, props.lang);
        const ret = {
            instance,
            lng: instance.language,
            _onLanguageChanged(lang) {
                mounted.current && setInternal((prevInstance) => (Object.assign(Object.assign({}, prevInstance), { lang })));
            },
        };
        if (!inServer) {
            instance.on('languageChanged', ret._onLanguageChanged);
        }
        return ret;
    });
    react_1.useEffect(() => {
        if (props.lang) {
            internal.instance.changeLanguage(props.lang); // and continue in languageChanged event handler
        }
    }, [props.lang]);
    react_1.useEffect(() => () => internal.instance.off('languageChanged', internal._onLanguageChanged), []);
    return react_1.createElement(I18NextReactContext.Provider, { value: internal }, props.children);
};
function useI18n() {
    return react_1.useContext(I18NextReactContext).instance;
}
exports.useI18n = useI18n;
/**
 * like {@link useI18n}, but return null when resource bundle not available
 * @param {string} lng
 * @param {string} ns
 * @returns {i18n | null}
 */
function useI18nLoaded(lng, ns) {
    const i18n = useI18n();
    const [resLoad, setResLoadCount] = react_1.useState(0);
    react_1.useEffect(() => {
        const triggerResourceCheck = () => setResLoadCount((_) => 1 + _);
        i18n.on('loaded', triggerResourceCheck);
        i18n.store.on('added', triggerResourceCheck);
        i18n.store.on('removed', triggerResourceCheck);
        return () => {
            i18n.off('loaded', triggerResourceCheck);
            /**
             * FIXME: remove type cast when my PR lands
             */
            i18n.store.off('added', triggerResourceCheck);
            i18n.store.off('removed', triggerResourceCheck);
        };
    }, [i18n]);
    return react_1.useMemo(() => i18n.hasResourceBundle(lng || '', ns || '') ? i18n.getFixedT(lng, ns) : null, [i18n, lng, ns, resLoad]);
}
exports.useI18nLoaded = useI18nLoaded;
function useMounted() {
    const mounted = react_1.useRef(false);
    react_1.useEffect(() => {
        mounted.current = true;
        return () => {
            mounted.current = false;
        };
    }, []);
    return mounted;
}
exports.useMounted = useMounted;
//# sourceMappingURL=i18next-react.js.map